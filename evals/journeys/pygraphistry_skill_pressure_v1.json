{
  "id": "pygraphistry_skill_pressure_v1",
  "description": "Expanded PyGraphistry skill pressure tests across loading/ETL/shaping/viz/search/analytics/AI/connectors/safety.",
  "eval_intent": "skill_pressure",
  "tags": ["pygraphistry", "skills", "pressure"],
  "cases": [
    {
      "id": "core_first_plot_with_auth",
      "prompt": "Provide a concise Python snippet for a first PyGraphistry graph from tiny edges/nodes tables with safe auth via environment variables, then produce a plot.",
      "checks": {
        "regex": [
          "register\\(",
          "api\\s*=\\s*3",
          "GRAPHISTRY_",
          "graphistry\\.edges\\(",
          "\\.nodes\\(",
          "\\.plot\\("
        ],
        "must_not_contain": [
          "EXAMPLE_USERNAME_LITERAL",
          "EXAMPLE_PASSWORD_LITERAL"
        ]
      }
    },
    {
      "id": "hypergraph_plus_materialize",
      "prompt": "Show a short snippet for turning row-oriented actor/event/location data into a graph and then preparing node-centric operations.",
      "checks": {
        "regex": [
          "hypergraph\\(",
          "materialize_nodes\\("
        ]
      }
    },
    {
      "id": "privacy_safe_share_url",
      "prompt": "Show a privacy-safe sharing snippet that keeps data private and returns a plot URL without rendering inline.",
      "checks": {
        "regex": [
          "privacy\\(mode\\s*=\\s*['\\\"](private|organization)['\\\"]\\)",
          "plot\\(render\\s*=\\s*False\\)"
        ]
      },
      "oracle": {
        "enabled": true,
        "min_score": 0.8,
        "reference_answer": "A strong answer shows non-public privacy mode and non-inline plotting to obtain a share URL safely.",
        "rubric": [
          "Must keep sharing non-public.",
          "Must use non-inline plotting for URL output.",
          "Should be concise and syntactically plausible."
        ],
        "required_concepts": [
          "non-public privacy mode",
          "non-inline URL workflow"
        ]
      }
    },
    {
      "id": "viz_encodings_and_layout_settings",
      "prompt": "Provide a short PyGraphistry styling snippet that encodes both node color and size, applies URL/layout settings, and then plots.",
      "checks": {
        "regex": [
          "encode_point_color\\(",
          "encode_point_size\\(",
          "url_params",
          "\\.plot\\("
        ]
      }
    },
    {
      "id": "static_export_text_modes",
      "prompt": "Show a snippet for static export that produces one textual graph format output (for example Graphviz DOT or Mermaid code).",
      "checks": {
        "regex": [
          "plot_static\\(",
          "graphviz-dot|mermaid-code"
        ]
      }
    },
    {
      "id": "gfql_local_pattern_hops",
      "prompt": "Write a minimal local GFQL traversal snippet that applies explicit hop bounds and returns a focused subgraph.",
      "checks": {
        "regex": [
          "(gfql\\(|\\bchain\\(|\\bhop\\()",
          "(min_hops\\s*=|max_hops\\s*=|hops\\s*=)"
        ]
      }
    },
    {
      "id": "gfql_remote_python_remote_postprocess",
      "prompt": "Provide a concise remote workflow snippet that queries remotely and then post-processes remote results with one python_remote_* helper.",
      "checks": {
        "regex": [
          "gfql_remote\\(",
          "python_remote_(table|g|json)\\("
        ]
      }
    },
    {
      "id": "hop_or_chain_for_neighborhood",
      "prompt": "Show a neighborhood expansion snippet with hop() or chain(), and briefly mention when to use GFQL instead.",
      "checks": {
        "regex": [
          "\\b(hop|chain)\\("
        ]
      },
      "oracle": {
        "enabled": true,
        "min_score": 0.85,
        "reference_answer": "A strong answer includes a valid hop()/chain() neighborhood expansion snippet and a short rationale for when GFQL is preferable (multi-step pattern constraints, explicit predicates/where logic, or remote-focused extraction).",
        "rubric": [
          "Must include a plausible neighborhood expansion snippet using hop() or chain().",
          "Must explain when GFQL is preferable, beyond just naming GFQL.",
          "Prefer concise guidance that distinguishes quick neighborhood expansion from richer pattern matching/query control."
        ],
        "required_concepts": [
          "hop or chain neighborhood expansion",
          "GFQL when constraints/pattern complexity increase"
        ]
      }
    },
    {
      "id": "ai_umap_dbscan",
      "prompt": "Provide a short Graph AI snippet with PyGraphistry using umap() followed by dbscan().",
      "checks": {
        "regex": [
          "umap\\(",
          "dbscan\\("
        ]
      }
    },
    {
      "id": "ai_semantic_search",
      "prompt": "Show a semantic search snippet after preparing features or embeddings.",
      "checks": {
        "regex": [
          "search\\(",
          "(umap|featurize|embed)\\("
        ]
      }
    },
    {
      "id": "connector_routing",
      "prompt": "In 3-5 bullets, explain connector strategy for Neo4j vs Splunk and include a dataframe-first fallback path.",
      "checks": {
        "regex": [
          "(?i)neo4j",
          "(?i)splunk",
          "(?i)dataframe|edges\\("
        ]
      },
      "oracle": {
        "enabled": true,
        "min_score": 0.8,
        "reference_answer": "A strong answer compares Neo4j and Splunk connector fit, then gives a practical dataframe-first fallback.",
        "rubric": [
          "Must explain connector choice rationale for Neo4j vs Splunk.",
          "Must include a dataframe fallback path.",
          "Should be concise and operational."
        ],
        "required_concepts": [
          "connector strategy",
          "dataframe fallback"
        ]
      }
    },
    {
      "id": "auth_safety",
      "prompt": "Give two safe-auth bullets for PyGraphistry credentials handling.",
      "checks": {
        "regex": [
          "(?i)environment",
          "GRAPHISTRY_"
        ],
        "must_not_contain": [
          "EXAMPLE_USERNAME_LITERAL",
          "EXAMPLE_PASSWORD_LITERAL"
        ],
        "max_lines": 4
      },
      "oracle": {
        "enabled": true,
        "min_score": 0.85,
        "reference_answer": "A strong answer gives two practical credential-safety bullets: env vars/secrets management and no hardcoded credentials in code/output.",
        "rubric": [
          "Must provide exactly two concise bullets.",
          "Must emphasize environment/secret-based credential handling.",
          "Must explicitly discourage hardcoded secrets."
        ],
        "required_concepts": [
          "environment-based credentials",
          "no hardcoded secrets"
        ]
      }
    }
  ]
}
