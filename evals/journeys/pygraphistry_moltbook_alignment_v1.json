{
  "id": "pygraphistry_moltbook_alignment_v1",
  "description": "Legacy alignment checks against older moltbook simulations for GFQL and visualization patterns. Useful for regression alignment, not primary real-world KPI scoring.",
  "eval_intent": "alignment_legacy",
  "tags": ["pygraphistry", "skills", "alignment", "moltbook"],
  "cases": [
    {
      "id": "gfql_edge_query_filter",
      "prompt": "Provide a concise GFQL snippet that filters edges by type using edge_query within one focused community/channel slice.",
      "checks": {
        "regex": [
          "(gfql|chain|node_query|hop)\\(",
          "edge_query\\s*(=\\s*f?['\\\"]|\\()",
          "(?i)type"
        ]
      }
    },
    {
      "id": "gfql_where_owner_compare",
      "prompt": "Show a short GFQL snippet using where=[...] with compare(col(...), '==', col(...)) to keep paths where endpoint nodes share the same attribute value.",
      "checks": {
        "regex": [
          "where\\s*=\\s*\\[",
          "compare\\(",
          "col\\("
        ]
      }
    },
    {
      "id": "gfql_output_hop_slicing",
      "prompt": "Write a minimal GFQL snippet that traverses a wider hop range but only returns a narrower output hop range.",
      "checks": {
        "regex": [
          "min_hops\\s*=\\s*\\d+",
          "max_hops\\s*=\\s*\\d+",
          "output_min_hops\\s*=\\s*\\d+",
          "output_max_hops\\s*=\\s*\\d+"
        ]
      }
    },
    {
      "id": "gfql_remote_nodes_subset",
      "prompt": "Provide a concise gfql_remote example that requests output_type='nodes' and limits payload with node_col_subset.",
      "checks": {
        "regex": [
          "gfql_remote\\(",
          "output_type\\s*=\\s*['\\\"]nodes['\\\"]",
          "node_col_subset\\s*=\\s*\\["
        ]
      }
    },
    {
      "id": "viz_external_layout_play0",
      "prompt": "Provide a short PyGraphistry snippet for using precomputed node coordinates x/y and disabling automatic playback for a static external layout view.",
      "checks": {
        "regex": [
          "bind\\(.*point_x\\s*=\\s*['\\\"]x['\\\"]",
          "point_y\\s*=\\s*['\\\"]y['\\\"]",
          "settings\\(",
          "url_params",
          "['\\\"]play['\\\"]\\s*:\\s*0"
        ]
      }
    },
    {
      "id": "viz_icon_and_badge",
      "prompt": "Show a concise PyGraphistry styling snippet that uses both encode_point_icon() and encode_point_badge().",
      "checks": {
        "regex": [
          "encode_point_icon\\(",
          "encode_point_badge\\("
        ]
      }
    },
    {
      "id": "viz_schema_hygiene_bullets",
      "prompt": "Give exactly 3 concise bullets on schema hygiene for Graphistry visuals: singleton type columns, avoiding dotted names, and native datetime usage.",
      "checks": {
        "regex": [
          "(?i)type",
          "(?i)dot|node\\.type|edge\\.type",
          "(?i)datetime"
        ],
        "max_lines": 6
      }
    }
  ]
}
